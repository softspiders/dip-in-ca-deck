import { Image, Notes, Head } from "mdx-deck";

import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";

import {
  vsDark as naiveTheme,
  nightOwl as smartTheme
} from "@code-surfer/themes"


import myTheme from './lib/theme'
export const theme = myTheme
//export const theme = smartTheme;

import counterWithLogger from "./diagrams/counterWithLogger.svg";

import naive from "./diagrams/naive.svg";
import naive1 from "./diagrams/naive1.svg";
import naive2 from "./diagrams/naive2.svg";
import naive3 from "./diagrams/naive3.svg";
import commonAbstraction from "./diagrams/commonAbstraction.svg";
import requiredInterface from "./diagrams/requiredInterface.svg";
import requiredInterface0 from "./diagrams/requiredInterface0.svg";
import requiredInterface2 from "./diagrams/requiredInterface2.svg";

<Head>
  <title>Принцип Инверсии Зависимостей</title>
</Head>

# Презентация презентации

<Notes>

Вначале немного о самой презентации

Все команды разработчиков, особенно те, что находятся на ранних этапах создания чего-либо, нуждаются в самых
разнообразных средствах общения, особенно если находятся в режиме удалённой работы.

Немаловажную роль в этих средствах общения играют инструменты наглядного донесения идей, планов, мыслей. 
И уже вполне традиционное место среди таких инструментов играют презентации.
  

Что хотелось попробовать в данном случае?

- Разработку презентации исключительно на инструментах Open Source
- Публикацию презентации, с постоянным публичным онлайн-доступом
- Создание презентации в жанре *статья-презентация*
- Использовать современные средства демонстрации программного кода

</Notes>

---

# Слайды + текст

<Notes>

А вообще складывается впечатление, что в последнее время понемногу формируются новые комбинированные жанры представления
информации, такие как видео + слайды, текст + видео (публикации такого формата теперь часто появляются на habr).

В данном случае предпринимается попытка попробовать сделать и показать ещё один гибридный вариант информационного
продукта: *слайды + текст*.

Этот вариант предполагает, что презентация должна обладать определённой степенью самодостаточности для того, чтобы её
можно было полноценно воспринимать даже при отсутствии докладчика.

Эта возможность обеспечивается тем, что в публикуемой презентации к слайдам добавляются заметки докладчика, которые
представлены не короткими подсказками, как это обычно бывает, а сравнительно более литературным текстом (насколько автор
может сделать его таковым), пригодным для восприятия не только докладчиком, но и каким-то кругом читателей.

</Notes>

---

### Для подготовки использовались инструменты:

- [mdx-deck](https://github.com/jxnblk/mdx-deck)
- [code-surfer](https://github.com/pomber/code-surfer)
- [drawio](https://github.com/jgraph/drawio)

<Notes>

Кратко об используемых инструментах:
- *MDX-DECK* - среда разработки презентаций на *markdown* + *React* (*mdx-deck* реализована на *React*)
- *Code Surfer* - плагин для *mdx-deck*, позволяющий красиво демонстрировать фрагменты кода
- *Draw.io* - продукт проекта *diagrams.net*, позволяющий бесплатно - в том числе на desktop и в онлайн - создавать
необходимые диаграммы.

Каждый из этих продуктов, конечно, сам по себе заслуживает отдельной презентации, в сети таких презентаций пока немного,
по *code-surfer* пока вообще не видел, но по *mdx-deck* они есть, хотя пока только англоязычные.

Но главная тема данной презентации всё-таки другая. 

В последующих докладах (до тех пор, пока не появится что-то лучшее) для подготовки презентаций предполагается
использовать именно этот набор инструментов.

</Notes>

---

# Режим докладчика

- *Alt+P* - на Windows
- *Option+P* - на Mac

<Notes>

Эту презентацию можно будет повторно пересмотреть-перечитать в режиме докладчика, при котором одномоментно виден и
слайд, и сопровождающий его текст.

Режим докладчика включается комбинацией клавиш *Alt+P* - на Windows и *Option+P* - на Mac.

</Notes>

---

# Презентация-стартер

<Notes>

Слайд можно понимать в двух смыслах: и как стартер презентации, и как стартер DIP-CA-решения.

В качестве повода для создания презентации в данном случае используется рассказ о принципе *Инверсии Зависимостей* -
фундаментальном принципе Чистой Архитектуры

</Notes>

---

# ЕЩЁ РАЗ 

---

# О ПРИНЦИПЕ
# ИНВЕРСИИ ЗАВИСИМОСТЕЙ

<Notes>

Этот принцип изложен на бесчисленном числе сетевых и прочих ресурсов.

Но по достоинству до сих пор так и не оценён.

Сделаем попытку это исправить.

Какова целевая аудитория у этой презентации ?

Конечно, в первую очередь, это разработчики, не знакомые или недостаточно хорошо знакомые  с принципом *Инверсии
Зависимостей*.

Но эта презентация может быть также интересна существенно большему кругу "зрителей-читателей", поскольку в ней помимо
инверсии зависимостей затрагиваются некоторые другие интересные вопросы.

Примеры кода приводятся на *TypeScript*, без сомнения они также будут понятны разработчикам на Java, на C#, и на прочих
языках, имеющих понятие интерфейса. 

</Notes>

---

# Вы узнаете

<Notes>

Из этой презентации вы узнаете

</Notes>

---

- В чём суть инверсии

---

- В чём суть инверсии
- При чём здесь *Чистая Архитектура*

---

- В чём суть инверсии
- При чём здесь *Чистая Архитектура*
- Как это выглядит на *TypeScript*
---

- В чём суть инверсии
- При чём здесь *Чистая Архитектура*
- Как это выглядит на *TypeScript*
- Как это выглядит на *UML*

---

- В чём суть инверсии
- При чём здесь *Чистая Архитектура*
- Как это выглядит на *TypeScript*
- Как это выглядит на *UML*
- И наверняка что-то ещё

---

<p style="font-size: 200px; text-align:left; font-weight:bold; padding:100px;">
S O L I D
</p>

<Notes>

Начнём с принципов SOLID.

</Notes>

---

<p style="font-size: 70px; text-align:left; padding:100px;">
    <i>"Использование принципов SOLID способствует созданию такой программной системы, которую будет легко поддерживать и расширять в течение долгого времени."</i>
    <p style="font-size: 50px; text-align:right; color:#addb67;">Из Википедии</p>
</p>

<Notes>

Почему для нас так важен именно SOLID ?

По сути принципы SOLID являются принципами *Чистой Архитектуры*.

В тех случаях, когда требуется создать долгоживущий проект с устойчивым развитием, следование этим принципам необходимо. 

При разработке корпоративного ПО такое качество, как способность к устойчивому развитию, является одним из главных
приоритетов.

</Notes>

---

- **S**ingle Responsibility Principle (SRP)

- **O**pen-Closed Principle (OCP)

- **L**iskov Substitution Principle (LCP)

- **I**nterface Segregation Principle (ICP)

- **D**ependency Inversion Principle (DIP)

<Notes>
Как известно, SOLID это аббревиатура, в которой каждая буква обозначает один из пяти принципов.
</Notes>

---

- **S**ingle Responsibility Principle (SRP)

- **O**pen-Closed Principle (OCP)

- **L**iskov Substitution Principle (LCP)

- **I**nterface Segregation Principle (ICP)

- **Dependency Inversion Principle** (**DIP**)

<Notes>
Данная презентация посвящена принципу, обозначенном последней буквой - 'D', но который, несмотря на своё последнее место,
для <i>Чистой Архитектуры</i>, пожалуй, является ключевым.

Как говорится, "The last but not the least".

</Notes>

---
# Как этого избежать ?

<Notes>

Рассмотрим простейший счётчик, которому нужно логировать изменения своего значения, в данном случае - выполнение функции
*increment()*.

</Notes>

---

<Image src={counterWithLogger} style={{ width: '100vw', height: '100vh'}}/>

<Notes>

UML-диаграмма решения может иметь такой вид.

Пунктирная стрелка с надписью *Use* в UML означает зависимость, причём, как нетрудно догадаться, благодаря надписи
*Use*, стрелка направлена от зависимого модуля к модулю-зависимости.

</Notes>

---

<CodeSurferColumns themes={[naiveTheme, naiveTheme]}>

<Step subtitle="Наивная реализация">

```ts file=../../src/naive/NaiveCounter.ts title="NaiveCounter"
```

```ts file=../../src/naive/ConsoleLogger.ts title="ConsoleLogger"
```

</Step>

</CodeSurferColumns>

<Notes>

Вначале рассмотрим код условно-наивной реализации счётчика.

В чём, собственно, наивность ?

</Notes>

---
<CodeSurferColumns themes={[naiveTheme, naiveTheme]}>

<Step subtitle="Design-time-зависимость от класса ConsoleLogger">

```ts 1,5 file=../../src/naive/NaiveCounter.ts title="NaiveCounter"
```

```ts 1 file=../../src/naive/ConsoleLogger.ts title="ConsoleLogger"
```

</Step>

</CodeSurferColumns>

<Notes>

Прежде всего она в том, что модуль бизнес-логики *NaiveCounter* имеет *зависимость времени разработки* -
*design-time-зависимость* от модуля *ConsoleLogger*, остальное уже вторично.

В таких случаях ещё часто говорят, что здесь присутствует ***зависимость от реализации***.

</Notes>

---

<Image src={naive} style={{ width: '100vw', height: '100vh'}}/>

<Notes>

Минусы этого решения для многих вполне очевидны, предполагается, что аудитория с ними знакома, поэтому останавливаться
на этом сейчас не будем.

Если говорить об UML-нотации, то стереотип *Use* практически говорит только о том, что в данном случае зависимость между
счётчиком и логгером присутствует просто, как таковая.

</Notes>

---

<Image src={naive1} style={{ width: '100vw', height: '100vh'}}/>

<Notes>

Но зависимости бывают разные. И, к слову сказать, для разных зависимостей в UML существует множество т.н стереотипов,
помечающих эти зависимости.

Отметим разницу между *design-time* и *run-time*-зависимостями.

</Notes>

---

<Image src={naive2} style={{ width: '100vw', height: '100vh'}}/>

<Notes>

*Run-time-зависимость* требует, чтобы во время выполнения программы код зависимого модуля и код модуля-зависимости
находились в одном и том же адресном пространстве. Самым распространённым случаем run-time-зависимости является
зависимость по вызову, когда код одного модуля зависит от вызываемого кода функций другого модуля.
В UML такие зависимости могут помечаться стереотипом *call*. 

*Design-time-зависимость* требует, чтобы исходные коды зависимого модуля и модуля-зависимости были одновременно доступны во
время разработки. Наиболее распространённым видом design-time-зависимости являются compile-time-зависимость, которая, в
частности, требует, чтобы оба модуля - зависимый и зависимость - находились в одном и том же пространстве имён. Такие
compile-time-зависимости в UML могут помечаться стереотипом *import*.

</Notes>

---

<Image src={naive3} style={{ width: '100vw', height: '100vh'}}/>

<Notes>

Очевидно, что во время выполнения показанного примера необходимо, чтобы из модуля бизнес-логики, в данном случае,
*NaiveCounter*, вызывался логгер.

Разумеется, что таким образом у в реализации присутствует call-зависимость бизнес-логики от логгера.

Но, как мы ранее видели в коде, *NaiveCounter* импортирует модуль *ConsoleLogger*, что явно показывает наличие у него
ещё и import-зависимости. 

В дальнейшем для краткости, если не будет специальных уточнений, под зависимостями будет подразумевать именно
import-зависимости.   

</Notes>

---

# D E C O U P L I N G

<Notes>

Как ранее уже было отмечено, зависимости создают множество, на первый взгляд, неочевидных проблем, но которые, в конце
концов, необходимо так или иначе решать.

В английском языке решение проблем такого рода называется ёмким словом - *decoupling*, что в данном контексте можно
перевести на русский, как *устранение зависимостей*.

Как именно это делается ?

</Notes>

---

# Интерфейсы

<Notes>

В качестве главного оружия борьбы с зависимостями служат *интерфейсы*.

Интерфейсы являются, наверное, одним из наиболее значимых понятий современного программирования и, хотя в языках они
появились не так уж давно, например, в C++ их ещё не было, сегодня они повсюду используются.

</Notes>

---

<Image src={commonAbstraction} style={{ width: '100vw', height: '100vh'}}/>

<Notes>

Здесь используется распространённый способ устранения/предотвращения *design-time*-зависимости, когда для обоих модулей,
имеющих между собой *run-time*-зависимость, устанавливается общая зависимость от интерфейса, который, как правило,
задаётся каким-то внешним стандартом.

И этот способ демонстрирует то, что называется *Принципом Инверсии Зависимостей*.

Главное здесь то, что ***модуль, использующий интерфейс, не зависит от модуля, реализующего интерфейс***.
Вызов происходит, но уже во время выполнения. Зависимость присутствует, но она уже не *import*, a *call*.

В таких случаях говорят, что оба модуля - и реализующий интерфейс, и использующий его - зависят от одной и той же
абстракции - от этого интерфейса.   

</Notes>

---

# Ну и где здесь инверсия?

<Notes>

На этом месте должен возникнуть хороший и закономерный вопрос: ну и где же здесь инверсия, что именно здесь инвертируется?

</Notes>

---

<p style="font-size: 50px; text-align:left; padding:100px;">
    <i>
    Может возникнуть вопрос, почему я использую слово “инверсия”. Откровенно говоря, это связано с тем, что более
    традиционные методы разработки программного обеспечения ..., как правило, создают программные структуры, в которых
    модули высокого уровня зависят от модулей низкого уровня, а абстракции зависят от деталей..., модули высокого уровня
    вызывают модули низкого уровня. ... Таким образом, структура зависимостей хорошо разработанной ... программы
    является “инвертированной” по отношению к структуре зависимостей, которая обычно является результатом традиционных
    процедурных методов.
    </i>
    <p style="font-size: 50px; text-align:right; color:#addb67;">Роберт Мартин</p>
</p>

<Notes>

В этой пространной цитате Мартин объясняет, причины, по которым он всё-таки использует понятие инверсии. 

То, что Мартин здесь называет "традиционными методами разработки" (а мы - условно наивными ;)), только что было показано
в уже приведённом примере, в нём не было никакой инверсии.

Но что Мартин здесь называет "хорошо разработанной программой"?

Об этом чуть дальше - будет показан другой пример, в котором инверсия зависимостей будет присутствовать уже в своём
буквальном виде.

</Notes>

---

## Но вначале о *требуемых интерфейсах*

<Notes>
...

Но вначале стоит рассмотреть понятие *требуемого интерфейса* (на английском - *required interface*).

...
</Notes>

---
<CodeSurferColumns themes={[myTheme, myTheme]}>

<Step title="Требуемый (required) интерфейс">

<Image align="middle" src="https://martinfowler.com/bliki/images/requiredInterface/requiredInterface_sketch.png" style={{ width: '40vw', height: '40vh', align: 'right' }}/>

<p style="font-size: 40px; text-align:left; padding:100px;">
    <i>
        A <b>required interface</b> is an interface that is defined by the client of an interaction that specifies what a
        supplier component needs to do so that it can be used in that interaction.
    </i>
    
    <p style="font-size: 50px; text-align:right; color:#addb67;">Martin Fowler</p>
</p>

</Step>

</CodeSurferColumns>

<Notes>

Так выглядит оригинальная картинка и определение Мартина Фаулера.

*Требуемый интерфейс* - интерфейс, определяемый вызывающей стороной, которая определяет, что должна сделать вызываемая
сторона, чтобы вызывающая сторона могла её использовать.

Здесь стоит обратить внимание на вполне наглядную нотацию, обозначающую взаимодействие модулей, один из которых -
слева - использует интерфейс, а другой - справа - его реализует.

Модуль, вызывающий методы интерфейса, и модуль, реализующий интерфейс, для краткости будем называть, соответственно,
*вызывающим* модулем и *реализующим* модулем.

</Notes>

---

<Image src={requiredInterface} style={{ width: '100vw', height: '100vh'}}/>

<Notes>

Особенность ситуации с *требуемым интерфейсом* состоит в том, что если в обычных случаях код вызывающего модуля пишется
под уже имеющийся интерфейс, то в случае *требуемого интерфейса* этот интерфейс определяется самим вызывающим модулем и,
как правило, непосредственно в своём теле.  

</Notes>

---

<CodeSurferColumns themes={[myTheme, myTheme]}>

<Step>

```ts file=../../src/dip/CounterInteractor.ts title="CounterInteractor"
```

```ts file=../../src/dip/ConsoleLogger.ts title="ConsoleLogger"
```

</Step>

</CodeSurferColumns>

<Notes>
...

Как это выглядит в *TypeScript* ?

Рассмотрим ещё одну реализацию счётчика, в которой на этот раз будет использован принцип *Инверсии Зависимостей*.

...
</Notes>

---

<CodeSurferColumns themes={[myTheme, myTheme]}>

<Step subtitle="У счётчика нет import-зависимости от логгера">

```ts 5:9,14,18 file=../../src/dip/CounterInteractor.ts title="CounterInteractor"
```

```ts 1,3 file=../../src/dip/ConsoleLogger.ts title="ConsoleLogger"
```

</Step>

</CodeSurferColumns>

<Notes>

Здесь *CounterInteractor* - вызывающий модуль, определяющий требуемый интерфейс *Logger* в своём теле.
 
*ConsoleLogger* - вызываемый модуль, реализующий требуемый интерфейс. 

И здесь у счётчика - *CounterInteractor*-а нет design-time-зависимости от логгера, хотя, конечно, run-time-зависимость
осталась.

В то же время реализация логгера *ConsoleLogger* зависит от счётчика, точнее от требуемого им интерфейса *Logger*.

</Notes>

---

<Image src={requiredInterface0} style={{ width: '100vw', height: '100vh'}}/>

<Notes>

Для большей наглядности рассмотрим диаграмму, показывающую взаимодействие этих модулей.

Здесь, наконец, уже можно увидеть инверсию: направление import-зависимости противоположно, то есть **инвертировано**
относительно направления call-зависимости, в то время, как при "традиционном" стиле разработки направления *call*- и
*import*-зависимостей совпадают. 
 
</Notes>

---

# Сравним эти реализации

<Notes>

В заключение сравним код этих двух реализаций. 
 
</Notes>

---

<CodeSurferColumns themes={[naiveTheme, myTheme]}>

<Step title="Головные модули">

```ts file=../../src/naive/index.ts subtitle="Наивная реализация"
```

```ts file=../../src/dip/index.ts subtitle="С использованием DIP"
```

</Step>

<Step title="Головные модули">

```ts 3 file=../../src/naive/index.ts subtitle="Наивная реализация"
```

```ts 2,4 file=../../src/dip/index.ts subtitle="С использованием DIP"
```

</Step>

</CodeSurferColumns>

---

<CodeSurferColumns themes={[naiveTheme, myTheme]}>

<Step title="Бизнес-логика - сами счётчики">

```ts file=../../src/naive/NaiveCounter.ts subtitle="Наивная реализация"
```

```ts file=../../src/dip/CounterInteractor.ts subtitle="С использованием DIP"
```

</Step>

<Step title="В главном нет различий">

```ts 7:10 file=../../src/naive/NaiveCounter.ts subtitle="Наивная реализация"
```

```ts 16:19 file=../../src/dip/CounterInteractor.ts subtitle="С использованием DIP"
```

</Step>

<Step title="Дьявол в деталях">

```ts 1,5 file=../../src/naive/NaiveCounter.ts subtitle="Design-time зависимость счётчика от реализации логгера"
```

```ts 5:9,14 file=../../src/dip/CounterInteractor.ts subtitle="Счётчик ничего не знает о реализации логгера"
```

</Step>

</CodeSurferColumns>

---

<CodeSurferColumns themes={[naiveTheme, myTheme]}>

<Step title="Логгеры">

```ts file=../../src/naive/ConsoleLogger.ts subtitle="Наивная реализация"
```

```ts file=../../src/dip/ConsoleLogger.ts subtitle="С использованием DIP"
```

</Step>

<Step title="Логгеры">

```ts file=../../src/naive/ConsoleLogger.ts subtitle="Логгер существует сам по себе"
```

```ts 1,3 file=../../src/dip/ConsoleLogger.ts subtitle="import-зависимость реализации логгера от требуемого интерфейса счётчика"
```

</Step>

<Step title="Логгеры">

```ts file=../../src/naive/ConsoleLogger.ts subtitle="Логгер существует сам по себе"
```

```ts 1,3[28:45] file=../../src/dip/ConsoleLogger.ts subtitle="Логгер реализует требуемый интерфейс счётчика"
```

</Step>

</CodeSurferColumns>

---

# СПАСИБО ЗА ВНИМАНИЕ!

---

# Исходники этой презентации

[https://github.com/softspiders/dip-in-ca](https://github.com/softspiders/dip-in-ca)
